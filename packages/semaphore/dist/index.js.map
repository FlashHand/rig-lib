{"version":3,"sources":["../src/semaphore.helper.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["type SemaphoreTask = {\n  n: number;\n  fn: () => void;\n};\n\n/**\n * Semaphore for concurrency control.\n * Inspired by abrkn/semaphore.js with TypeScript & async/await support.\n */\nexport class Semaphore {\n  /** Total capacity */\n  readonly capacity: number;\n\n  private _current: number;\n  private readonly queue: SemaphoreTask[] = [];\n\n  constructor(capacity: number = 1) {\n    if (capacity < 1) {\n      throw new Error('Semaphore: capacity must be at least 1');\n    }\n    this.capacity = capacity;\n    this._current = capacity;\n  }\n\n  /** Current available slots */\n  get current(): number {\n    return this._current;\n  }\n\n  /** Number of tasks waiting in the queue */\n  get queueLength(): number {\n    return this.queue.length;\n  }\n\n  /**\n   * Acquire `n` slots. When slots are available, `fn` is called.\n   * - `take(fn)` — acquire 1 slot\n   * - `take(n, fn)` — acquire `n` slots\n   */\n  take(fn: () => void): void;\n  take(n: number, fn: () => void): void;\n  take(...args: any[]): void {\n    let n: number;\n    let fn: () => void;\n\n    if (args.length === 1) {\n      n = 1;\n      fn = args[0];\n    } else {\n      n = args[0];\n      fn = args[1];\n    }\n\n    if (typeof fn !== 'function') {\n      throw new Error('Semaphore: callback must be a function');\n    }\n\n    if (n > this.capacity) {\n      throw new Error(`Semaphore: requested ${n} exceeds capacity ${this.capacity}`);\n    }\n\n    this.queue.push({ n, fn });\n    this.dispatch();\n  }\n\n  /**\n   * Promise-based acquire. Resolves when `n` slots are available.\n   * Usage: await sem.takeAsync(n?)\n   */\n  takeAsync = (n: number = 1): Promise<void> => {\n    return new Promise<void>((resolve, reject) => {\n      try {\n        this.take(n, resolve);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n\n  /** Release `n` slots (default 1) */\n  leave = (n: number = 1): void => {\n    this._current = Math.min(this._current + n, this.capacity);\n\n    // Dispatch as many queued tasks as possible\n    let dispatched = true;\n    while (dispatched && this.queue.length > 0 && this.queue[0].n <= this._current) {\n      const before = this.queue.length;\n      this.dispatch();\n      dispatched = this.queue.length < before;\n    }\n  };\n\n  /** Check if `n` slots are available (default 1) */\n  available = (n: number = 1): boolean => {\n    return this._current >= n;\n  };\n\n  /** Acquire all capacity. `fn` is called when all slots are acquired. */\n  drain = (fn: () => void): void => {\n    this.take(this.capacity, fn);\n  };\n\n  /** Promise-based drain. Resolves when all slots are acquired. */\n  drainAsync = (): Promise<void> => {\n    return this.takeAsync(this.capacity);\n  };\n\n  private dispatch = (): void => {\n    if (this.queue.length === 0 || this._current <= 0) return;\n\n    const next = this.queue[0];\n    if (next.n > this._current) return;\n\n    this.queue.shift();\n    this._current -= next.n;\n    next.fn();\n  };\n}\n"]}